---
phase: 06-write-operations
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/blocks/md-to-blocks.ts
  - tests/blocks/md-to-blocks.test.ts
autonomous: true
requirements:
  - WRITE-01
  - WRITE-03
must_haves:
  truths:
    - "Markdown paragraph text converts to Notion paragraph block"
    - "Markdown headings (# ## ###) convert to heading_1/2/3 blocks"
    - "Markdown bullet lists convert to bulleted_list_item blocks"
    - "Markdown numbered lists convert to numbered_list_item blocks"
    - "Markdown code fences convert to code blocks with language"
    - "Markdown blockquotes convert to quote blocks"
    - "Inline bold/italic/code annotations are preserved in rich_text arrays"
    - "Blank lines between blocks do not generate empty blocks"
  artifacts:
    - path: "src/blocks/md-to-blocks.ts"
      provides: "mdToBlocks() — converts markdown string to Notion API block array"
      exports: ["mdToBlocks"]
    - path: "tests/blocks/md-to-blocks.test.ts"
      provides: "TDD test suite (RED→GREEN verified)"
      min_lines: 80
  key_links:
    - from: "src/blocks/md-to-blocks.ts"
      to: "@notionhq/client API types"
      via: "BlockObjectRequest import"
      pattern: "BlockObjectRequest"
---

<objective>
TDD plan: Build a markdown → Notion blocks converter that the `append` and `create-page` commands will use to send markdown content to Notion.

Purpose: The Notion API accepts blocks as JSON objects (e.g. `{ type: "paragraph", paragraph: { rich_text: [...] } }`). When a user writes `notion append <id> -m "# Hello\nWorld"`, the CLI must convert that markdown string to valid Notion API block payloads before calling `blocks.children.append()`.

Output: `src/blocks/md-to-blocks.ts` exporting `mdToBlocks(md: string): BlockObjectRequest[]` — fully tested via TDD.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Key interfaces this plan works with:
# From @notionhq/client, the relevant write type is BlockObjectRequest
# (not BlockObjectResponse used in reading — different type for create/append)
# The Notion API accepts blocks.children.append({ block_id, children: BlockObjectRequest[] })

# Existing rich-text reader for reference (inverse of what we're building):
@src/blocks/rich-text.ts
@src/blocks/converters.ts

# Test pattern reference:
@tests/blocks/rich-text.test.ts
</context>

<feature>
  <name>mdToBlocks — markdown string to Notion API block array</name>
  <files>src/blocks/md-to-blocks.ts, tests/blocks/md-to-blocks.test.ts</files>
  <behavior>
    Input: a markdown string (may contain multiple lines and blank lines)
    Output: BlockObjectRequest[] — array of Notion API block objects

    Parse line-by-line with these rules:
    - `# text` → `{ type: "heading_1", heading_1: { rich_text: [rt(text)] } }`
    - `## text` → `{ type: "heading_2", heading_2: { rich_text: [rt(text)] } }`
    - `### text` → `{ type: "heading_3", heading_3: { rich_text: [rt(text)] } }`
    - `- text` or `* text` → `{ type: "bulleted_list_item", bulleted_list_item: { rich_text: [rt(text)] } }`
    - `1. text` (any digit + period) → `{ type: "numbered_list_item", numbered_list_item: { rich_text: [rt(text)] } }`
    - `> text` → `{ type: "quote", quote: { rich_text: [rt(text)] } }`
    - ` ```lang\n...``` ` (multi-line fence) → `{ type: "code", code: { rich_text: [rt(content)], language: lang || "plain text" } }`
    - blank line → skip (no block generated)
    - everything else → `{ type: "paragraph", paragraph: { rich_text: [rt(text)] } }`

    Inline annotation parsing for rich_text (applied to all non-code lines):
    - `**text**` → bold annotation
    - `_text_` or `*text*` → italic annotation
    - `` `text` `` → code annotation
    - `[label](url)` → text with link
    - Plain text → no annotations

    The rt() function returns RichTextItemRequest:
    `{ type: "text", text: { content: string, link: {url} | null }, annotations: { bold, italic, code, ... } }`

    Edge cases to test:
    - empty string → []
    - only blank lines → []
    - mixed content → correct block sequence
    - heading with inline bold → heading block with bold rich_text
    - code fence without language → language: "plain text"
    - code fence with language tag → language preserved
  </behavior>
  <implementation>
    Create `src/blocks/md-to-blocks.ts`:

    1. Import `BlockObjectRequest` and `RichTextItemRequest` from `@notionhq/client/build/src/api-endpoints.js`

    2. Implement `parseInlineMarkdown(text: string): RichTextItemRequest[]` — a simple regex-based parser:
       - Use a single-pass regex to split text into annotated segments
       - Handle bold `**...**`, italic `_..._` and `*...*`, inline code `` `...` ``, links `[label](url)`
       - Return array of RichTextItemRequest objects
       - For simplicity: process in order bold → italic → code → links, no nesting needed

    3. Implement `mdToBlocks(md: string): BlockObjectRequest[]` — line-by-line parser:
       - Split on `\n`
       - Detect code fences: when line starts with ` ``` `, enter fence mode; accumulate lines until closing ` ``` `; emit code block
       - For non-fence lines: match heading/list/quote/bullet patterns via regex
       - Skip blank lines
       - Call `parseInlineMarkdown()` for rich_text content on all text-bearing lines

    Keep it simple — no nested lists, no HTML, no front-matter stripping. The goal is "good enough for AI agent output patterns": paragraphs, headings, bullets, numbered, code blocks, quotes.

    TypeScript note: `BlockObjectRequest` in SDK v5 uses discriminated union. Use type assertions where needed:
    `{ type: "paragraph", paragraph: { rich_text: rts } } as BlockObjectRequest`
  </implementation>
</feature>

<tasks>

<task type="tdd">
  <name>RED: Write failing tests for mdToBlocks</name>
  <files>tests/blocks/md-to-blocks.test.ts</files>
  <action>
    Create `tests/blocks/md-to-blocks.test.ts` with test cases for all block types and inline annotations.
    Import `mdToBlocks` from `../../src/blocks/md-to-blocks.js` (file doesn't exist yet — tests MUST fail).

    Test cases to include:
    - `mdToBlocks('')` → `[]`
    - `mdToBlocks('\n\n')` → `[]`
    - `mdToBlocks('Hello world')` → paragraph block with plain text rich_text
    - `mdToBlocks('# Heading')` → heading_1 block
    - `mdToBlocks('## Subheading')` → heading_2 block
    - `mdToBlocks('### Section')` → heading_3 block
    - `mdToBlocks('- item')` → bulleted_list_item block
    - `mdToBlocks('* item')` → bulleted_list_item block
    - `mdToBlocks('1. item')` → numbered_list_item block
    - `mdToBlocks('> quote text')` → quote block
    - Code fence: `mdToBlocks('` + '```' + `ts\nconsole.log()\n` + '```' + `')` → code block with language "ts"
    - Code fence no lang: → code block with language "plain text"
    - `mdToBlocks('**bold**')` → paragraph with bold annotation in rich_text
    - `mdToBlocks('_italic_')` → paragraph with italic annotation
    - `` mdToBlocks('`code`') `` → paragraph with code annotation
    - `mdToBlocks('[label](url)')` → paragraph with link

    Run: `npm test -- --reporter=verbose tests/blocks/md-to-blocks.test.ts` — MUST FAIL at this point.
    Commit: `test(06-01): add failing tests for mdToBlocks`
  </action>
  <verify>
    <automated>cd /Users/andrzejchm/Developer/notion-cli && npm test -- tests/blocks/md-to-blocks.test.ts 2>&1 | tail -20</automated>
  </verify>
  <done>All tests fail with "Cannot find module" or type errors — source file doesn't exist yet</done>
</task>

<task type="tdd">
  <name>GREEN: Implement mdToBlocks to pass all tests</name>
  <files>src/blocks/md-to-blocks.ts</files>
  <action>
    Create `src/blocks/md-to-blocks.ts` implementing `parseInlineMarkdown()` and `mdToBlocks()` as described in the feature behavior section.

    Key implementation notes:
    - Use `BlockObjectRequest` type from `@notionhq/client/build/src/api-endpoints.js`
    - Code fence detection: track `inFence` boolean, `fenceLines` accumulator, `fenceLang` string
    - For inline parsing, a simple approach: split text using regex captures for bold/italic/code/links
      Example regex: `/(\*\*[^*]+\*\*|_[^_]+_|\*[^*]+\*|`[^`]+`|\[[^\]]+\]\([^)]+\)|[^*_`\[]+)/g`
    - Return `[]` for empty/blank-only input

    Run: `npm test -- tests/blocks/md-to-blocks.test.ts` — MUST PASS.
    Run: `npm test` — full suite must still pass (no regressions).
    Commit: `feat(06-01): implement mdToBlocks markdown-to-blocks converter`
  </action>
  <verify>
    <automated>cd /Users/andrzejchm/Developer/notion-cli && npm test 2>&1 | tail -20</automated>
  </verify>
  <done>All tests pass including new md-to-blocks suite. `npm test` exit code 0.</done>
</task>

</tasks>

<verification>
`npm test` passes with zero failures. The new `tests/blocks/md-to-blocks.test.ts` covers all documented block types and inline annotations.
</verification>

<success_criteria>
- `mdToBlocks("# Hello\nWorld")` returns `[heading_1 block, paragraph block]`
- `mdToBlocks("")` returns `[]`
- Code fence with language tag produces correct `language` field
- Inline bold/italic/code produce correct `annotations` in `rich_text`
- Full test suite passes: `npm test` exit code 0
</success_criteria>

<output>
After completion, create `.planning/phases/06-write-operations/06-01-SUMMARY.md`
</output>
