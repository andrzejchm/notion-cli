---
phase: 04-database-operations
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/database.service.ts
autonomous: true
requirements:
  - DB-01
  - DB-02
  - DB-03
  - DB-04
  - DB-05

must_haves:
  truths:
    - "fetchDatabaseSchema() returns property names, types, and select/status option names"
    - "queryDatabase() returns all matching entries (auto-paginates)"
    - "buildFilter() converts --filter 'Prop=Value' strings into Notion API filter objects using schema property types"
    - "buildSorts() converts --sort 'Prop:asc' strings into Notion API sort objects"
    - "displayPropertyValue() converts any database property value to a short display string"
    - "Filter building handles: select, status, multi_select, checkbox, number, title, rich_text, url, email"
    - "Unknown properties in --filter produce a clear CliError, not a silent failure"
  artifacts:
    - path: "src/services/database.service.ts"
      provides: "Database API layer: schema fetch, filtered/sorted query, filter/sort builders, display formatter"
      exports: ["fetchDatabaseSchema", "queryDatabase", "buildFilter", "buildSorts", "displayPropertyValue", "DatabaseSchema", "DatabaseEntry", "DatabaseQueryOptions"]
  key_links:
    - from: "src/commands/db/schema.ts"
      to: "src/services/database.service.ts"
      via: "import { fetchDatabaseSchema } from '../../services/database.service.js'"
      pattern: "fetchDatabaseSchema"
    - from: "src/commands/db/query.ts"
      to: "src/services/database.service.ts"
      via: "import { queryDatabase, buildFilter, buildSorts, displayPropertyValue } from '../../services/database.service.js'"
      pattern: "queryDatabase|buildFilter|buildSorts"
---

<objective>
Build the database service layer: schema fetching, filtered/sorted entry querying, and CLI-flag-to-API-filter translation.

Purpose: All database command logic is data-fetching and transformation — isolating it here keeps the command files thin and makes the business logic testable. The filter builder is the most complex piece — it must inspect property types from the schema before constructing Notion API filter objects.
Output: src/services/database.service.ts — the complete data layer for Phase 4 commands.
</objective>

<execution_context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
</execution_context>

<context>
@.planning/phases/01-foundation-auth/01-04-SUMMARY.md
@.planning/research/PITFALLS.md
@.planning/research/ARCHITECTURE.md

<interfaces>
<!-- Phase 1 infrastructure -->
From src/notion/client.ts:
```typescript
export function createNotionClient(token: string): Client
```

From src/errors/cli-error.ts:
```typescript
export class CliError extends Error {
  constructor(code: string, message: string, suggestion?: string)
}
```

From src/errors/codes.ts:
```typescript
export const ErrorCodes = { API_ERROR, API_NOT_FOUND, API_RATE_LIMITED, ... } as const
```

From src/output/paginate.ts (Phase 2):
```typescript
export async function paginateResults<T>(
  fetcher: (cursor?: string) => Promise<{ results: T[]; next_cursor: string | null; has_more: boolean }>
): Promise<T[]>
```

<!-- Notion SDK types for databases -->
From @notionhq/client:
```typescript
import { Client, isFullPage } from '@notionhq/client';
import type {
  DatabaseObjectResponse,
  PageObjectResponse,
  PropertyItemObjectResponse,
  QueryDatabaseParameters,
} from '@notionhq/client/build/src/api-endpoints.js';

// databases.retrieve(dbId) → DatabaseObjectResponse
// DatabaseObjectResponse.properties: Record<string, { id, name, type, ...typeSpecificConfig }>
//   e.g. { 'Status': { type: 'select', select: { options: [{name:'Done',color:'green'}, ...] } } }
//        { 'Priority': { type: 'number', number: { format: 'number' } } }
//        { 'Tags': { type: 'multi_select', multi_select: { options: [{name:'Bug',...}] } } }

// databases.query(params) → { results: PageObjectResponse[], next_cursor, has_more }
// Each result is a PageObjectResponse; access properties via result.properties

// SDK NOTE: In @notionhq/client v5, database queries may use client.databases.query()
// Verify the actual SDK method name — it may be client.databases.query() or
// client.dataSources.query(). Check node_modules/@notionhq/client/build/src/Client.d.ts
// to confirm the correct method before implementing.
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database service (schema + query + filter/sort builders + display formatter)</name>
  <files>src/services/database.service.ts</files>
  <action>
Create `src/services/database.service.ts` with all database data-fetching and transformation logic.

**Types to export:**
```typescript
export interface DatabaseSchema {
  id: string;
  title: string;
  // Property configs from schema — maps prop name to its type and options
  properties: Record<string, DatabasePropertyConfig>;
}

export interface DatabasePropertyConfig {
  id: string;
  name: string;
  type: string; // 'select' | 'status' | 'number' | 'title' | 'rich_text' | 'date' | etc.
  // For select/status/multi_select: available options
  options?: Array<{ name: string; color?: string }>;
}

export interface DatabaseEntry {
  id: string;
  // Property values — maps prop name to display string
  properties: Record<string, string>;
  // Raw page object for JSON output
  raw: PageObjectResponse;
}

export interface DatabaseQueryOptions {
  filter?: QueryDatabaseParameters['filter'];
  sorts?: QueryDatabaseParameters['sorts'];
  // Subset of property names to include (undefined = all)
  columns?: string[];
}
```

**fetchDatabaseSchema(client, dbId): Promise<DatabaseSchema>**
```typescript
export async function fetchDatabaseSchema(
  client: Client,
  dbId: string,
): Promise<DatabaseSchema> {
  const db = await client.databases.retrieve({ database_id: dbId });
  // Verify using: check Client.d.ts for correct method name (databases.retrieve or dataSources.retrieve)

  const title = db.title.map(rt => rt.plain_text).join('') || dbId;

  const properties: Record<string, DatabasePropertyConfig> = {};
  for (const [name, prop] of Object.entries(db.properties)) {
    const config: DatabasePropertyConfig = {
      id: prop.id,
      name,
      type: prop.type,
    };
    // Extract options for enumerable types
    if (prop.type === 'select' && 'select' in prop) {
      config.options = prop.select.options;
    } else if (prop.type === 'status' && 'status' in prop) {
      config.options = prop.status.options;
    } else if (prop.type === 'multi_select' && 'multi_select' in prop) {
      config.options = prop.multi_select.options;
    }
    properties[name] = config;
  }

  return { id: dbId, title, properties };
}
```

**queryDatabase(client, dbId, opts): Promise<DatabaseEntry[]>**
```typescript
export async function queryDatabase(
  client: Client,
  dbId: string,
  opts: DatabaseQueryOptions = {},
): Promise<DatabaseEntry[]> {
  const rawPages = await paginateResults((cursor) =>
    client.databases.query({
      database_id: dbId,
      filter: opts.filter,
      sorts: opts.sorts,
      start_cursor: cursor,
      page_size: 100,
    }),
  );

  return rawPages.filter(isFullPage).map((page) => {
    const propValues: Record<string, string> = {};
    for (const [name, prop] of Object.entries(page.properties)) {
      // Skip columns not requested (if --columns specified)
      if (opts.columns && !opts.columns.includes(name)) continue;
      propValues[name] = displayPropertyValue(prop);
    }
    return { id: page.id, properties: propValues, raw: page };
  });
}
```

**buildFilter(filterStrings, schema): Notion filter object | undefined**

Parse `--filter "Status=Done"` strings into Notion PropertyFilter objects.
The schema is needed to know which filter type to use per property.

```typescript
export function buildFilter(
  filterStrings: string[],
  schema: DatabaseSchema,
): QueryDatabaseParameters['filter'] | undefined {
  if (!filterStrings.length) return undefined;

  const filters = filterStrings.map((raw) => {
    const eqIdx = raw.indexOf('=');
    if (eqIdx === -1) {
      throw new CliError('INVALID_ARG', `Invalid filter syntax: "${raw}"`, 'Use format: --filter "PropertyName=Value"');
    }
    const propName = raw.slice(0, eqIdx).trim();
    const value = raw.slice(eqIdx + 1).trim();
    const propConfig = schema.properties[propName];
    if (!propConfig) {
      const available = Object.keys(schema.properties).join(', ');
      throw new CliError('INVALID_ARG', `Property "${propName}" not found`, `Available properties: ${available}`);
    }
    return buildPropertyFilter(propName, propConfig.type, value);
  });

  return filters.length === 1 ? filters[0] : { and: filters };
}

function buildPropertyFilter(
  property: string,
  type: string,
  value: string,
): object {
  switch (type) {
    case 'select':
      return { property, select: { equals: value } };
    case 'status':
      return { property, status: { equals: value } };
    case 'multi_select':
      return { property, multi_select: { contains: value } };
    case 'checkbox':
      return { property, checkbox: { equals: value.toLowerCase() === 'true' } };
    case 'number':
      return { property, number: { equals: Number(value) } };
    case 'title':
      return { property, title: { contains: value } };
    case 'rich_text':
      return { property, rich_text: { contains: value } };
    case 'url':
      return { property, url: { contains: value } };
    case 'email':
      return { property, email: { contains: value } };
    default:
      throw new CliError('INVALID_ARG', `Filtering by property type "${type}" is not supported`);
  }
}
```

**buildSorts(sortStrings): Notion sorts array**
Parse `--sort "Status:asc"` or `--sort "Created:desc"`:
```typescript
export function buildSorts(
  sortStrings: string[],
): NonNullable<QueryDatabaseParameters['sorts']> {
  return sortStrings.map((raw) => {
    const colonIdx = raw.lastIndexOf(':');
    if (colonIdx === -1) {
      return { property: raw.trim(), direction: 'ascending' as const };
    }
    const property = raw.slice(0, colonIdx).trim();
    const dir = raw.slice(colonIdx + 1).trim().toLowerCase();
    return {
      property,
      direction: dir === 'desc' || dir === 'descending' ? 'descending' as const : 'ascending' as const,
    };
  });
}
```

**displayPropertyValue(prop): string — inline formatter for table display**

This is a database-specific formatter (NOT the same as Phase 3's properties.ts which handles page-reading context):

```typescript
export function displayPropertyValue(prop: PageObjectResponse['properties'][string]): string {
  switch (prop.type) {
    case 'title':     return prop.title.map(r => r.plain_text).join('');
    case 'rich_text': return prop.rich_text.map(r => r.plain_text).join('');
    case 'number':    return prop.number !== null && prop.number !== undefined ? String(prop.number) : '';
    case 'select':    return prop.select?.name ?? '';
    case 'status':    return prop.status?.name ?? '';
    case 'multi_select': return prop.multi_select.map(s => s.name).join(', ');
    case 'date':      return prop.date ? (prop.date.end ? `${prop.date.start} → ${prop.date.end}` : prop.date.start) : '';
    case 'checkbox':  return prop.checkbox ? '✓' : '✗';
    case 'url':       return prop.url ?? '';
    case 'email':     return prop.email ?? '';
    case 'phone_number': return prop.phone_number ?? '';
    case 'people':    return prop.people.map(p => ('name' in p && p.name ? p.name : p.id)).join(', ');
    case 'relation':  return prop.relation.length > 0 ? `[${prop.relation.length}]` : '';
    case 'formula': {
      const f = prop.formula;
      if (f.type === 'string')  return f.string ?? '';
      if (f.type === 'number')  return f.number !== null && f.number !== undefined ? String(f.number) : '';
      if (f.type === 'boolean') return f.boolean ? 'true' : 'false';
      if (f.type === 'date')    return f.date?.start ?? '';
      return '';
    }
    case 'created_time':      return prop.created_time;
    case 'last_edited_time':  return prop.last_edited_time;
    case 'unique_id':
      return prop.unique_id.prefix
        ? `${prop.unique_id.prefix}-${prop.unique_id.number}`
        : String(prop.unique_id.number ?? '');
    default: return '';
  }
}
```

**Imports:**
```typescript
import { Client, isFullPage } from '@notionhq/client';
import type { PageObjectResponse, QueryDatabaseParameters } from '@notionhq/client/build/src/api-endpoints.js';
import { CliError } from '../errors/cli-error.js';
import { paginateResults } from '../output/paginate.js';
```

Note: If `paginateResults` is not yet available (Phase 2 not yet executed), the executor must stub it inline as a simple do-while loop over `next_cursor` — then update the import once Phase 2 is confirmed complete.
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep "database.service.ts" || echo "no errors"</verify>
  <done>src/services/database.service.ts exists, exports all 7 symbols (DatabaseSchema, DatabasePropertyConfig, DatabaseEntry, DatabaseQueryOptions, fetchDatabaseSchema, queryDatabase, buildFilter, buildSorts, displayPropertyValue). TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with 0 errors in database.service.ts
- All 7 exports present and correctly typed
- buildFilter('Status=Done', schema) returns correct select filter for a select property
- buildFilter('Unknown=X', schema) throws CliError with list of available properties
- buildSorts(['Title:asc', 'Created:desc']) returns correctly shaped array
- displayPropertyValue handles all property types without throwing
</verification>

<success_criteria>
- src/services/database.service.ts compiles cleanly
- fetchDatabaseSchema uses client.databases.retrieve and returns DatabaseSchema
- queryDatabase uses paginateResults and returns DatabaseEntry[]
- buildFilter correctly maps property type → Notion filter shape
- buildSorts handles asc/desc/ascending/descending variants
- displayPropertyValue is self-contained (no Phase 3 dependency)
</success_criteria>

<output>
After completion, create `.planning/phases/04-database-operations/04-01-SUMMARY.md`
</output>
