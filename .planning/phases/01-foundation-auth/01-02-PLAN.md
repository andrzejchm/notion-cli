---
phase: 01-foundation-auth
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/config/paths.ts
  - src/config/config.ts
  - src/config/local-config.ts
  - src/config/token.ts
  - tests/config/paths.test.ts
  - tests/config/config.test.ts
  - tests/config/token.test.ts
autonomous: true
requirements:
  - AUTH-03
  - AUTH-04

must_haves:
  truths:
    - "Config file is read from $XDG_CONFIG_HOME/notion-cli/config.yaml or ~/.config/notion-cli/config.yaml"
    - "Config file is written atomically (temp file + rename)"
    - "Config file has 0600 permissions"
    - "Token resolution checks env var first, then .notion.yaml, then active profile"
    - "Token source is reported (env, local file, or profile name)"
    - ".notion.yaml can specify either profile name or direct token"
  artifacts:
    - path: "src/config/paths.ts"
      provides: "XDG-aware config path resolution"
      exports: ["getConfigDir", "getConfigPath"]
    - path: "src/config/config.ts"
      provides: "Global config read/write with atomic writes"
      exports: ["readGlobalConfig", "writeGlobalConfig"]
    - path: "src/config/local-config.ts"
      provides: "Local .notion.yaml reading"
      exports: ["readLocalConfig"]
    - path: "src/config/token.ts"
      provides: "Token resolution chain with source reporting"
      exports: ["resolveToken"]
  key_links:
    - from: "src/config/token.ts"
      to: "src/config/config.ts"
      via: "reads active profile from global config"
      pattern: "readGlobalConfig"
    - from: "src/config/token.ts"
      to: "src/config/local-config.ts"
      via: "reads .notion.yaml for local override"
      pattern: "readLocalConfig"
    - from: "src/config/config.ts"
      to: "src/config/paths.ts"
      via: "uses getConfigPath() for file location"
      pattern: "getConfigPath"
---

<objective>
Implement the config management system: XDG-aware paths, global config YAML read/write, local .notion.yaml support, and the token resolution chain with source reporting.

Purpose: Establish the config infrastructure that `notion init` and all authenticated commands depend on. Token resolution is the critical path — every API call needs a token.
Output: Working config read/write, local config reading, and token resolution with layered precedence (env > local > profile).
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md
@.planning/phases/01-foundation-auth/01-01-SUMMARY.md

<interfaces>
<!-- Types from Plan 01 that this plan depends on -->

From src/types/config.ts:
```typescript
export interface ProfileConfig {
  token: string;
  workspace_name?: string;
  workspace_id?: string;
}

export interface GlobalConfig {
  active_profile?: string;
  profiles?: Record<string, ProfileConfig>;
}

export interface LocalConfig {
  profile?: string;
  token?: string;
}

export interface TokenResult {
  token: string;
  source: 'NOTION_API_TOKEN' | '.notion.yaml' | `profile: ${string}`;
}
```

From src/errors/cli-error.ts:
```typescript
export class CliError extends Error {
  constructor(code: ErrorCode, message: string, suggestion?: string);
  format(): string;
}
```

From src/errors/codes.ts:
```typescript
export const ErrorCodes: {
  AUTH_NO_TOKEN: 'AUTH_NO_TOKEN';
  CONFIG_READ_ERROR: 'CONFIG_READ_ERROR';
  CONFIG_WRITE_ERROR: 'CONFIG_WRITE_ERROR';
  CONFIG_INVALID: 'CONFIG_INVALID';
  // ...
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config paths, global config read/write, and local config</name>
  <files>
    src/config/paths.ts
    src/config/config.ts
    src/config/local-config.ts
  </files>
  <action>
1. Create `src/config/paths.ts` — XDG-aware path resolution:
   - `getConfigDir()`: returns `$XDG_CONFIG_HOME/notion-cli` or `~/.config/notion-cli`
   - `getConfigPath()`: returns `getConfigDir() + '/config.yaml'`
   - Use `node:os` `homedir()` and `node:path` `join()`
   - Follow research pattern (XDG Config Path Resolution section)

2. Create `src/config/config.ts` — global config read/write:
   - `readGlobalConfig(): Promise<GlobalConfig>` — reads and parses YAML. Returns `{}` on ENOENT. Throws `CliError(CONFIG_READ_ERROR)` on parse failure.
   - `writeGlobalConfig(config: GlobalConfig): Promise<void>` — atomic write:
     a. `mkdir` config dir with `{ recursive: true, mode: 0o700 }`
     b. Write to `config.yaml.tmp` with `{ mode: 0o600 }`
     c. `rename` tmp to config.yaml (atomic)
   - Use `yaml` package (`parse`, `stringify`) — import from `'yaml'`
   - Use `node:fs/promises` for ALL file I/O (never sync — per research anti-patterns)
   - Import types from `../types/config.ts`

3. Create `src/config/local-config.ts`:
   - `readLocalConfig(): Promise<LocalConfig | null>` — reads `.notion.yaml` from `process.cwd()`
   - Returns `null` if file doesn't exist (ENOENT)
   - Validates: must have either `profile` (string) OR `token` (string), not both. If both present, throw `CliError(CONFIG_INVALID, '...')` with suggestion to use one or the other.
   - Use `yaml` package for parsing
  </action>
  <verify>
    <automated>npx vitest run tests/config/paths.test.ts tests/config/config.test.ts 2>/dev/null || npm run build</automated>
  </verify>
  <done>
- `getConfigDir()` respects `$XDG_CONFIG_HOME` env var with `~/.config/notion-cli` fallback
- `readGlobalConfig()` returns `{}` when no config file exists
- `writeGlobalConfig()` creates directory, writes atomically, sets 0600 permissions
- `readLocalConfig()` returns `null` when no `.notion.yaml` exists
- `.notion.yaml` with both `profile` and `token` throws CONFIG_INVALID error
  </done>
</task>

<task type="auto">
  <name>Task 2: Token resolution chain with tests</name>
  <files>
    src/config/token.ts
    tests/config/paths.test.ts
    tests/config/config.test.ts
    tests/config/token.test.ts
  </files>
  <action>
1. Create `src/config/token.ts` — token resolution per research Pattern 2:
   - `resolveToken(): Promise<TokenResult>` — layered lookup:
     a. Check `process.env.NOTION_API_TOKEN` → return `{ token, source: 'NOTION_API_TOKEN' }`
     b. Read `.notion.yaml` via `readLocalConfig()`:
        - If `token` field present → return `{ token, source: '.notion.yaml' }`
        - If `profile` field present → look up that profile in global config
     c. Read global config via `readGlobalConfig()`:
        - If `active_profile` set → look up that profile's token
     d. If nothing found → throw `CliError(AUTH_NO_TOKEN, 'No authentication token found.', 'Run "notion init" to set up a profile')`
   - Import from `./config.ts`, `./local-config.ts`, `../types/config.ts`, `../errors/cli-error.ts`

2. Create `tests/config/paths.test.ts`:
   - Test `getConfigDir()` returns correct path with `XDG_CONFIG_HOME` set
   - Test `getConfigDir()` falls back to `~/.config/notion-cli` without `XDG_CONFIG_HOME`
   - Test `getConfigPath()` appends `config.yaml`

3. Create `tests/config/config.test.ts`:
   - Test `readGlobalConfig()` returns `{}` when file doesn't exist
   - Test `writeGlobalConfig()` + `readGlobalConfig()` round-trip (use tmp dir)
   - Test `readLocalConfig()` returns `null` when no `.notion.yaml`

4. Create `tests/config/token.test.ts`:
   - Test env var takes precedence over everything
   - Test `.notion.yaml` token field works
   - Test `.notion.yaml` profile field looks up global config
   - Test active profile fallback works
   - Test throws AUTH_NO_TOKEN when nothing configured
   - Mock file system or use tmp dirs for isolation
  </action>
  <verify>
    <automated>npx vitest run tests/config/ --reporter=verbose</automated>
  </verify>
  <done>
- Token resolution follows precedence: env > .notion.yaml > active profile
- All tests pass for config paths, config read/write, and token resolution
- AUTH_NO_TOKEN error thrown when no token found anywhere
- Token source correctly reported for each resolution path
  </done>
</task>

</tasks>

<verification>
- `npx vitest run tests/config/` — all config tests pass
- `npm run build` — project still builds
- Token resolution precedence verified by tests
</verification>

<success_criteria>
1. Config paths resolve correctly with XDG support
2. Global config reads/writes YAML atomically with correct permissions
3. Local .notion.yaml reads and validates (profile XOR token)
4. Token resolution chain implements full precedence (env > local > profile)
5. All config tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-02-SUMMARY.md`
</output>
