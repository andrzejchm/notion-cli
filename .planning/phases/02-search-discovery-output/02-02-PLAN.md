---
phase: 02-search-discovery-output
plan: "02"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/commands/search.ts
  - src/commands/ls.ts
autonomous: true
requirements:
  - SRCH-01
  - SRCH-02
  - SRCH-03

must_haves:
  truths:
    - "User can search workspace by keyword with notion search <query>"
    - "Search results can be filtered by page or database type via --type flag"
    - "User can list all accessible content with notion ls"
  artifacts:
    - path: "src/commands/search.ts"
      provides: "notion search <query> command — keyword search with optional type filter"
      exports: ["searchCommand"]
    - path: "src/commands/ls.ts"
      provides: "notion ls command — list all accessible pages and databases"
      exports: ["lsCommand"]
  key_links:
    - from: "src/commands/search.ts"
      to: "src/output/format.ts"
      via: "printOutput(results, headers, rows)"
      pattern: "printOutput"
    - from: "src/commands/search.ts"
      to: "src/output/paginate.ts"
      via: "paginateResults((cursor) => notion.search(...))"
      pattern: "paginateResults"
    - from: "src/commands/ls.ts"
      to: "src/output/paginate.ts"
      via: "paginateResults((cursor) => notion.search({start_cursor: cursor}))"
      pattern: "paginateResults"
---

<objective>
Implement `notion search <query>` and `notion ls` commands — the two primary workspace discovery commands.

Purpose: These are the entry points for finding content in Notion. Both use the shared formatter and pagination utility from 02-01.
Output: src/commands/search.ts and src/commands/ls.ts — fully implemented, not yet wired into CLI (that's 02-04).
</objective>

<execution_context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
</execution_context>

<context>
@.planning/phases/02-search-discovery-output/02-01-SUMMARY.md

<interfaces>
<!-- From 02-01: output utilities -->
From src/output/format.ts:
```typescript
export type OutputMode = 'auto' | 'json' | 'md';
export function setOutputMode(mode: OutputMode): void
export function getOutputMode(): OutputMode
export function isatty(): boolean
export function isHumanMode(): boolean
export function formatJSON(data: unknown): string
export function formatTable(rows: string[][], headers: string[]): string
export function printOutput(data: unknown, tableHeaders?: string[], tableRows?: string[][]): void
```

From src/output/paginate.ts:
```typescript
export async function paginateResults<T>(
  fetcher: (cursor?: string) => Promise<{ results: T[]; next_cursor: string | null; has_more: boolean }>
): Promise<T[]>
```

<!-- From Phase 1: auth and client -->
From src/config/token.ts:
```typescript
export async function resolveToken(): Promise<TokenResult>
// TokenResult = { token: string; source: 'NOTION_API_TOKEN' | '.notion.yaml' | `profile: ${string}` }
```

From src/notion/client.ts:
```typescript
export function createNotionClient(token: string): Client
// Client is @notionhq/client's Client class
```

From src/output/stderr.ts:
```typescript
export function reportTokenSource(source: TokenResult['source']): void
```

From src/errors/error-handler.ts:
```typescript
export function withErrorHandling<T extends (...args: any[]) => Promise<void>>(fn: T): T
```

<!-- Notion SDK search response shape -->
Notion SDK search() returns objects of type PageObjectResponse | PartialPageObjectResponse | DatabaseObjectResponse | PartialDatabaseObjectResponse.
Use only the "full" variants (object has `properties`/`title` field) — filter via:
```typescript
import { isFullPage, isFullDatabase } from '@notionhq/client';
// isFullPage(item) — true if complete page object
// isFullDatabase(item) — true if complete database object
```

Full page object key fields:
```typescript
{
  object: 'page',
  id: string,          // UUID with dashes
  url: string,
  last_edited_time: string,  // ISO8601
  created_time: string,
  properties: {
    // The title property has type === 'title'
    [key: string]: { type: 'title'; title: Array<{ plain_text: string }> } | OtherPropertyTypes
  }
}
```

Full database object key fields:
```typescript
{
  object: 'database',
  id: string,          // UUID with dashes
  url: string,
  last_edited_time: string,
  created_time: string,
  title: Array<{ plain_text: string }>  // database title is top-level
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: notion search command</name>
  <files>src/commands/search.ts</files>
  <action>
Create `src/commands/search.ts` implementing the `notion search <query>` command.

**Command signature:**
```
notion search <query> [--type page|database] [--json]
```

**Command factory function:**
```typescript
export function searchCommand(): Command
```

**Implementation steps:**
1. Use `resolveToken()` → `createNotionClient(token)` (standard pattern from Phase 1)
2. Call `reportTokenSource(source)` to stderr
3. Call `paginateResults((cursor) => notion.search({ query, filter: type ? { property: 'object', value: type } : undefined, start_cursor: cursor }))`
4. Filter results to full objects only: `results.filter(r => isFullPage(r) || isFullDatabase(r))`
5. Extract display data with a `getTitle` helper:
   ```typescript
   function getTitle(item: PageObjectResponse | DatabaseObjectResponse): string {
     if (item.object === 'database') {
       return item.title.map(t => t.plain_text).join('') || '(untitled)';
     }
     const titleProp = Object.values(item.properties).find(p => p.type === 'title');
     if (titleProp?.type === 'title') {
       return titleProp.title.map(t => t.plain_text).join('') || '(untitled)';
     }
     return '(untitled)';
   }
   ```
6. Build table rows: `[item.object, getTitle(item), item.id, item.last_edited_time.split('T')[0]]`
7. Call `printOutput(results, ['TYPE', 'TITLE', 'ID', 'MODIFIED'], rows)`

**Command options:**
- `<query>` — required positional argument (the search keyword)
- `--type <type>` — optional, choices: `page`, `database` — filter results
- `--json` — force JSON output; call `setOutputMode('json')` before fetching

**Empty results:** If results array is empty, print `No results found for "${query}"` to stdout and exit 0.

**Wrap action in `withErrorHandling`.**
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep "search.ts" || echo "no errors"</verify>
  <done>src/commands/search.ts exports searchCommand(), compiles cleanly, implements --type filter and --json flag, uses paginateResults and printOutput</done>
</task>

<task type="auto">
  <name>Task 2: notion ls command</name>
  <files>src/commands/ls.ts</files>
  <action>
Create `src/commands/ls.ts` implementing `notion ls` — lists all pages and databases the integration can access.

**Command signature:**
```
notion ls [--type page|database] [--json]
```

**Command factory function:**
```typescript
export function lsCommand(): Command
```

**Implementation:**
1. Use `resolveToken()` → `createNotionClient(token)` (standard Phase 1 pattern)
2. Call `reportTokenSource(source)` to stderr
3. `paginateResults((cursor) => notion.search({ start_cursor: cursor }))` — empty query returns all accessible content
4. Filter to full objects, optionally filter by type:
   ```typescript
   let items = results.filter(r => isFullPage(r) || isFullDatabase(r));
   if (type) items = items.filter(r => r.object === type);
   ```
5. Build table rows using the same `getTitle` logic as search.ts (extract to shared utility or inline — inline is fine here, it's 6 lines)
6. Table columns: `['TYPE', 'TITLE', 'ID', 'MODIFIED']`
7. Call `printOutput(items, headers, rows)`

**Command options:**
- `--type <type>` — optional, choices: `page`, `database` — filter by object type
- `--json` — force JSON output

**Empty results:** Print `No accessible content found` to stdout and exit 0.

**Wrap action in `withErrorHandling`.**

Note: `notion ls` intentionally does NOT sort results (Notion API returns in last-edited order, which is the most useful default).
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep "ls.ts" || echo "no errors"</verify>
  <done>src/commands/ls.ts exports lsCommand(), compiles cleanly, uses paginateResults with empty search query, supports --type filter and --json</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors in search.ts or ls.ts
- Both commands import from correct relative paths: `../output/format.js`, `../output/paginate.js`, `../notion/client.js`, `../config/token.js`, `../output/stderr.js`, `../errors/error-handler.js`
- `getTitle()` handles both page (title property) and database (top-level title) correctly
- `--type` flag accepts only `page` or `database` (Commander choices validation)
</verification>

<success_criteria>
- src/commands/search.ts and src/commands/ls.ts exist and export their command factories
- Both use paginateResults for transparent auto-pagination
- Both route output through printOutput (JSON or table based on mode)
- TypeScript compiles cleanly
- Empty results handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-discovery-output/02-02-SUMMARY.md`
</output>
