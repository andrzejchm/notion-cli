---
phase: 02-search-discovery-output
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/output/format.ts
  - src/output/paginate.ts
autonomous: true
requirements:
  - OUT-01
  - OUT-02
  - OUT-03
  - OUT-04
  - SRCH-05

must_haves:
  truths:
    - "Commands display formatted tables when stdout is a TTY"
    - "Commands output JSON when piped (no TTY)"
    - "--json flag forces JSON output regardless of TTY"
    - "--md flag forces markdown output for page content"
    - "All list/search commands auto-paginate Notion API without user intervention"
  artifacts:
    - path: "src/output/format.ts"
      provides: "OutputMode management, table rendering, JSON output, TTY detection"
      exports: ["OutputMode", "setOutputMode", "getOutputMode", "formatTable", "formatJSON", "isatty"]
    - path: "src/output/paginate.ts"
      provides: "Auto-pagination for Notion cursor-based API calls"
      exports: ["paginateResults"]
  key_links:
    - from: "src/commands/*.ts"
      to: "src/output/format.ts"
      via: "import { getOutputMode, formatTable, formatJSON } from '../output/format.js'"
      pattern: "getOutputMode|formatTable|formatJSON"
    - from: "src/commands/*.ts"
      to: "src/output/paginate.ts"
      via: "import { paginateResults } from '../output/paginate.js'"
      pattern: "paginateResults"
---

<objective>
Build the output formatting system and auto-pagination utility that all Phase 2 commands will use.

Purpose: Dual-mode output (TTY tables vs JSON) and transparent pagination are foundational to every search/list command — they must exist before any command is implemented.
Output: src/output/format.ts (output mode + table rendering) and src/output/paginate.ts (pagination helper)
</objective>

<execution_context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
</execution_context>

<context>
@.planning/phases/01-foundation-auth/01-01-SUMMARY.md
@.planning/phases/01-foundation-auth/01-04-SUMMARY.md

<interfaces>
<!-- Existing output utilities — extend, don't replace -->
From src/output/color.ts:
```typescript
export function setColorForced(forced: boolean): void
export function createChalk(): Chalk
export function error(msg: string): string
export function success(msg: string): string
export function dim(msg: string): string
export function bold(msg: string): string
```

From src/output/stderr.ts:
```typescript
export function stderrWrite(msg: string): void
export function reportTokenSource(source: TokenResult['source']): void
```

From src/errors/codes.ts:
```typescript
export const ErrorCodes = { API_ERROR, API_RATE_LIMITED, API_NOT_FOUND, ... } as const
```

Notion SDK response shape (cursor-based pagination):
```typescript
// All list/search responses follow this shape
interface NotionListResponse<T> {
  results: T[];
  next_cursor: string | null;
  has_more: boolean;
}
// Example: notion.search() returns SearchResponse matching this shape
// Example: notion.users.list() returns ListUsersResponse matching this shape
// Example: notion.comments.list() returns ListCommentsResponse matching this shape
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Output formatter (format.ts)</name>
  <files>src/output/format.ts</files>
  <action>
Create `src/output/format.ts` that manages output mode and provides rendering functions.

**OutputMode type and module-level state:**
```typescript
export type OutputMode = 'auto' | 'json' | 'md';
let _mode: OutputMode = 'auto';
export function setOutputMode(mode: OutputMode): void { _mode = mode; }
export function getOutputMode(): OutputMode { return _mode; }
```

**TTY detection:**
```typescript
export function isatty(): boolean {
  return Boolean(process.stdout.isTTY);
}

// Derived: should we show human-readable output?
export function isHumanMode(): boolean {
  if (_mode === 'json') return false;
  if (_mode === 'md') return false;  // md mode: caller decides rendering
  return isatty();  // 'auto': check TTY
}
```

**formatJSON(data: unknown): string**
- Returns `JSON.stringify(data, null, 2)`
- Used for JSON output mode or piped mode

**formatTable(rows: string[][], headers: string[]): string**
Hand-roll a simple column-aligned ASCII table. No external dependencies.
- Calculate max width per column from headers + all rows (cap column widths at sensible maxes to prevent long titles from wrecking layout)
- Column widths: TYPE=8, TITLE=min(longest title, 50), ID=32, other columns natural width
- Separator line uses `─` repeated for total width
- Header row: `HEADER1  HEADER2  HEADER3`
- Separator: `────────  ────────  ────────`
- Data rows: each cell left-padded to column width, truncated with `…` if too long
- Columns separated by two spaces
- Returns multi-line string (no trailing newline)

Example output for search results:
```
TYPE      TITLE                                              ID                               MODIFIED
────────  ─────────────────────────────────────────────────  ───────────────────────────────  ────────────────────
page      My Document                                        abc123def456789012345678901234  2026-02-20
database  Project Tracker                                    def789abc012345678901234567890  2026-02-15
```

**printOutput(data: unknown, tableHeaders?: string[], tableRows?: string[][]): void**
Convenience function:
- If mode is 'json' OR (!isatty() AND mode is 'auto'): write `formatJSON(data)` to stdout
- If isHumanMode() AND tableHeaders/tableRows provided: write `formatTable(tableRows, tableHeaders)` to stdout
- Always ends with a newline

This is the single function all commands call — no mode-checking scattered in command files.
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep "format.ts" || echo "no errors"</verify>
  <done>src/output/format.ts exists and exports OutputMode, setOutputMode, getOutputMode, isatty, isHumanMode, formatJSON, formatTable, printOutput — all compile cleanly</done>
</task>

<task type="auto">
  <name>Task 2: Pagination utility (paginate.ts)</name>
  <files>src/output/paginate.ts</files>
  <action>
Create `src/output/paginate.ts` with a single generic `paginateResults` function.

**Function signature:**
```typescript
export async function paginateResults<T>(
  fetcher: (cursor?: string) => Promise<{ results: T[]; next_cursor: string | null; has_more: boolean }>
): Promise<T[]>
```

**Implementation:**
```typescript
export async function paginateResults<T>(
  fetcher: (cursor?: string) => Promise<{ results: T[]; next_cursor: string | null; has_more: boolean }>
): Promise<T[]> {
  const allResults: T[] = [];
  let cursor: string | undefined;

  do {
    const response = await fetcher(cursor);
    allResults.push(...response.results);
    cursor = response.next_cursor ?? undefined;
  } while (response.has_more);

  return allResults;
}
```

**Usage pattern commands will follow:**
```typescript
// notion search
const results = await paginateResults((cursor) =>
  notion.search({ query, filter: type ? { property: 'object', value: type } : undefined, start_cursor: cursor })
);

// notion users
const results = await paginateResults((cursor) =>
  notion.users.list({ start_cursor: cursor })
);

// notion comments
const results = await paginateResults((cursor) =>
  notion.comments.list({ block_id: pageId, start_cursor: cursor })
);
```

No additional dependencies. Pure TypeScript.
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep "paginate.ts" || echo "no errors"</verify>
  <done>src/output/paginate.ts exists and exports paginateResults<T> — compiles cleanly, generic type correctly inferred from fetcher return shape</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors in format.ts or paginate.ts
- `formatTable` produces properly aligned output for varying column widths
- `printOutput` routes to JSON when piped (mode=auto + !isTTY) and table when TTY
- `paginateResults` collects all pages across Notion cursor pagination
</verification>

<success_criteria>
- src/output/format.ts and src/output/paginate.ts exist
- TypeScript compiles cleanly
- formatTable handles truncation at 50 chars with `…` for long titles
- printOutput picks JSON vs table mode correctly
- paginateResults signature: `(fetcher: (cursor?) => Promise<{results, next_cursor, has_more}>) => Promise<T[]>`
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-discovery-output/02-01-SUMMARY.md`
</output>
