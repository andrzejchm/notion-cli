---
phase: 03-page-reading
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/page.service.ts
  - src/blocks/properties.ts
autonomous: true
requirements:
  - PAGE-03

must_haves:
  truths:
    - "fetchPageWithBlocks() recursively fetches all block children (not just top-level)"
    - "Block tree is represented as BlockNode[] where each node has block + children"
    - "Recursive fetching uses controlled concurrency (≤3 parallel) to respect Notion rate limits"
    - "fetchPageWithBlocks() accepts a depth limit (default 10) to prevent infinite loops"
    - "formatPropertyValue() handles all P1 property types (title, rich_text, number, select, multi_select, date, people, checkbox, url, email, phone_number, relation, formula, rollup, created_time, last_edited_time)"
    - "Property values convert to readable strings (e.g. date → ISO string, multi_select → comma-joined names)"
  artifacts:
    - path: "src/services/page.service.ts"
      provides: "Recursive block tree fetcher + page retrieval"
      exports: ["fetchPageWithBlocks", "BlockNode", "PageWithBlocks"]
    - path: "src/blocks/properties.ts"
      provides: "Property value to display string formatter"
      exports: ["formatPropertyValue", "extractPageTitle"]
  key_links:
    - from: "src/services/page.service.ts"
      to: "src/notion/client.ts"
      via: "import { createNotionClient } from '../notion/client.js'"
      pattern: "createNotionClient"
    - from: "src/blocks/render.ts"
      to: "src/blocks/properties.ts"
      via: "import { formatPropertyValue, extractPageTitle } from './properties.js'"
      pattern: "formatPropertyValue|extractPageTitle"
    - from: "src/blocks/render.ts"
      to: "src/services/page.service.ts"
      via: "import type { BlockNode, PageWithBlocks } from '../services/page.service.js'"
      pattern: "BlockNode|PageWithBlocks"
---

<objective>
Build the page data fetching service and property value formatter that power the `notion read` command.

Purpose: The page service handles the recursive block tree challenge (the most complex Notion API interaction), while the properties formatter converts typed property values into readable strings for the metadata header. Both are needed before Plan 03-04 can assemble the final markdown.
Output: src/services/page.service.ts (page+blocks fetcher) and src/blocks/properties.ts (property formatter)
</objective>

<execution_context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
</execution_context>

<context>
@.planning/phases/01-foundation-auth/01-04-SUMMARY.md
@.planning/research/PITFALLS.md
@.planning/research/ARCHITECTURE.md

<interfaces>
<!-- Existing auth/client infrastructure -->
From src/notion/client.ts:
```typescript
export function createNotionClient(token: string): Client
```

From src/notion/url-parser.ts:
```typescript
export function parseNotionId(input: string): string // returns 32-char hex
```

From src/config/config.ts:
```typescript
export async function readGlobalConfig(): Promise<GlobalConfig>
```

From src/types/config.ts:
```typescript
export interface TokenResult {
  token: string;
  source: 'NOTION_API_TOKEN' | '.notion.yaml' | `profile: ${string}`;
}
```

<!-- Notion SDK types needed -->
From @notionhq/client:
```typescript
import { Client, collectPaginatedAPI } from '@notionhq/client';
import type {
  BlockObjectResponse,
  PageObjectResponse,
  PartialBlockObjectResponse,
} from '@notionhq/client/build/src/api-endpoints.js';
// Note: use isFullBlock(block) type guard to narrow PartialBlockObjectResponse → BlockObjectResponse

// Property value types (simplified — actual SDK has full union):
// PageObjectResponse.properties is Record<string, PropertyItemObjectResponse>
// Property types: title, rich_text, number, select, multi_select, date, people,
//   checkbox, url, email, phone_number, relation, formula, rollup,
//   created_time, last_edited_time, created_by, last_edited_by, files, status
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Recursive block tree fetcher (page.service.ts)</name>
  <files>src/services/page.service.ts</files>
  <action>
Create `src/services/page.service.ts` with two exported types and two exported functions.

**Types to export:**
```typescript
export interface BlockNode {
  block: BlockObjectResponse;
  children: BlockNode[];
}

export interface PageWithBlocks {
  page: PageObjectResponse;
  blocks: BlockNode[];
}
```

**fetchPageWithBlocks(client: Client, pageId: string): Promise<PageWithBlocks>**

Implementation steps:
1. Call `client.pages.retrieve({ page_id: pageId })` to get the page object
2. Call internal `fetchBlockTree(client, pageId, 0, 10)` to get the block tree
3. Return `{ page, blocks }`

**fetchBlockTree(client, blockId, depth, maxDepth): Promise<BlockNode[]>** — internal, not exported

Implementation:
```typescript
async function fetchBlockTree(
  client: Client,
  blockId: string,
  depth: number,
  maxDepth: number,
): Promise<BlockNode[]> {
  if (depth >= maxDepth) return [];

  // Use collectPaginatedAPI to get all children (handles has_more automatically)
  const rawBlocks = await collectPaginatedAPI(client.blocks.children.list, {
    block_id: blockId,
  });

  // Filter to full blocks only (type guard)
  const blocks = rawBlocks.filter(isFullBlock);

  // Controlled concurrency: process blocks in batches of 3 to respect rate limits
  const nodes: BlockNode[] = [];
  for (let i = 0; i < blocks.length; i += 3) {
    const batch = blocks.slice(i, i + 3);
    const batchNodes = await Promise.all(
      batch.map(async (block) => {
        const children = block.has_children
          ? await fetchBlockTree(client, block.id, depth + 1, maxDepth)
          : [];
        return { block, children };
      }),
    );
    nodes.push(...batchNodes);
  }

  return nodes;
}
```

**Import isFullBlock** from `@notionhq/client`:
```typescript
import { Client, collectPaginatedAPI, isFullBlock } from '@notionhq/client';
```

**Error handling:** Let CliError from error-handler propagate naturally. A 404 from `pages.retrieve` will be caught by `withErrorHandling` in the command layer and mapped to `API_NOT_FOUND`. Add a specific "page not shared with integration" message via the `ErrorCodes.API_NOT_FOUND` message in the error handler (already handles this in Phase 1 error-handler.ts).

No `resolveToken` here — the service receives an already-authenticated `Client`.
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep "page.service.ts" || echo "no errors"</verify>
  <done>src/services/page.service.ts exists, exports BlockNode, PageWithBlocks, fetchPageWithBlocks. TypeScript compiles cleanly. collectPaginatedAPI used for pagination, batch-of-3 concurrency for recursion.</done>
</task>

<task type="auto">
  <name>Task 2: Property value formatter (properties.ts)</name>
  <files>src/blocks/properties.ts</files>
  <action>
Create `src/blocks/properties.ts` that converts Notion page property values to display strings.

**Functions to export:**

```typescript
// Convert any property value to a display string
export function formatPropertyValue(
  name: string,
  prop: PageObjectResponse['properties'][string],
): string

// Extract the page title from properties (title property is special)
export function extractPageTitle(page: PageObjectResponse): string
```

**formatPropertyValue() implementation — handle each property type:**

```typescript
// title → join plain_text of all rich text items
case 'title': return prop.title.map(rt => rt.plain_text).join('');

// rich_text → join plain_text
case 'rich_text': return prop.rich_text.map(rt => rt.plain_text).join('');

// number → string or '' if null
case 'number': return prop.number !== null ? String(prop.number) : '';

// select → name or ''
case 'select': return prop.select?.name ?? '';

// status → name or ''
case 'status': return prop.status?.name ?? '';

// multi_select → comma-joined names
case 'multi_select': return prop.multi_select.map(s => s.name).join(', ');

// date → start date ISO string (include end if present)
case 'date':
  if (!prop.date) return '';
  return prop.date.end ? `${prop.date.start} → ${prop.date.end}` : prop.date.start;

// checkbox → 'true' or 'false'
case 'checkbox': return prop.checkbox ? 'true' : 'false';

// url → the URL string or ''
case 'url': return prop.url ?? '';

// email → the email string or ''
case 'email': return prop.email ?? '';

// phone_number → string or ''
case 'phone_number': return prop.phone_number ?? '';

// people → comma-joined names (use .name for full users, .id for partial)
case 'people':
  return prop.people
    .map(p => ('name' in p && p.name ? p.name : p.id))
    .join(', ');

// relation → comma-joined page IDs (page titles would require extra API calls — skip)
case 'relation': return prop.relation.map(r => r.id).join(', ');

// formula → extract the formula result value
case 'formula':
  const f = prop.formula;
  if (f.type === 'string') return f.string ?? '';
  if (f.type === 'number') return f.number !== null ? String(f.number) : '';
  if (f.type === 'boolean') return String(f.boolean);
  if (f.type === 'date') return f.date?.start ?? '';
  return '';

// rollup → use number or string from rollup result
case 'rollup':
  const r = prop.rollup;
  if (r.type === 'number') return r.number !== null ? String(r.number) : '';
  if (r.type === 'date') return r.date?.start ?? '';
  if (r.type === 'array') return `[${r.array.length} items]`;
  return '';

// created_time / last_edited_time → ISO string (already in prop)
case 'created_time': return prop.created_time;
case 'last_edited_time': return prop.last_edited_time;

// created_by / last_edited_by → name or id
case 'created_by':
  return 'name' in prop.created_by ? (prop.created_by.name ?? prop.created_by.id) : prop.created_by.id;
case 'last_edited_by':
  return 'name' in prop.last_edited_by ? (prop.last_edited_by.name ?? prop.last_edited_by.id) : prop.last_edited_by.id;

// files → comma-joined file names
case 'files':
  return prop.files.map(f => ('name' in f ? f.name : f.external?.url ?? '')).join(', ');

// unique_id → prefix-number or just number
case 'unique_id':
  return prop.unique_id.prefix
    ? `${prop.unique_id.prefix}-${prop.unique_id.number}`
    : String(prop.unique_id.number ?? '');

// Default: return empty string for unrecognized types
default: return '';
```

**extractPageTitle(page):**
```typescript
export function extractPageTitle(page: PageObjectResponse): string {
  // Find the 'title' type property
  const titleProp = Object.values(page.properties).find(p => p.type === 'title');
  if (!titleProp || titleProp.type !== 'title') return page.id;
  return titleProp.title.map(rt => rt.plain_text).join('') || page.id;
}
```

Import `PageObjectResponse` from `@notionhq/client/build/src/api-endpoints.js`.
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep "properties.ts" || echo "no errors"</verify>
  <done>src/blocks/properties.ts exists, exports formatPropertyValue and extractPageTitle. Handles all 15+ property types. TypeScript compiles cleanly with no type errors.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with 0 errors in page.service.ts and properties.ts
- page.service.ts exports BlockNode interface, PageWithBlocks interface, fetchPageWithBlocks function
- fetchPageWithBlocks uses collectPaginatedAPI for block listing
- Recursive fetching uses batch-of-3 concurrency
- properties.ts exports formatPropertyValue and extractPageTitle
- All 15+ property types handled with non-crashing defaults
</verification>

<success_criteria>
- src/services/page.service.ts and src/blocks/properties.ts both compile cleanly
- BlockNode type: { block: BlockObjectResponse; children: BlockNode[] }
- PageWithBlocks type: { page: PageObjectResponse; blocks: BlockNode[] }
- fetchPageWithBlocks() fetches page + full block tree
- formatPropertyValue() handles all property types without throwing
- extractPageTitle() returns page title string or page ID as fallback
</success_criteria>

<output>
After completion, create `.planning/phases/03-page-reading/03-02-SUMMARY.md`
</output>
