---
phase: 03-page-reading
plan: "01"
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/blocks/rich-text.ts
  - tests/blocks/rich-text.test.ts
autonomous: true
requirements:
  - PAGE-04

must_haves:
  truths:
    - "Bold text (annotations.bold=true) renders as **text**"
    - "Italic text (annotations.italic=true) renders as _text_"
    - "Inline code (annotations.code=true) renders as `text`"
    - "Strikethrough renders as ~~text~~"
    - "Links render as [text](href) with annotations applied inside"
    - "Bold+italic combined renders as **_text_**"
    - "Multiple rich text segments concatenate in order"
    - "Mentions render as plain text (user name, page title, or @date)"
    - "Equations render as $expression$"
    - "Empty rich text array returns empty string"
  artifacts:
    - path: "src/blocks/rich-text.ts"
      provides: "Rich text segment array to markdown string conversion"
      exports: ["richTextToMd"]
    - path: "tests/blocks/rich-text.test.ts"
      provides: "Test coverage for all annotation types and combinations"
      contains: "describe('richTextToMd'"
  key_links:
    - from: "src/blocks/converters.ts"
      to: "src/blocks/rich-text.ts"
      via: "import { richTextToMd } from './rich-text.js'"
      pattern: "richTextToMd"
---

<objective>
Build the rich text annotation converter that translates Notion's rich text segments into markdown strings.

Purpose: Every block type contains rich text. This module is the foundational leaf-level converter that all block converters depend on. Building it test-first ensures all annotation combinations produce correct markdown before any blocks are wired up.
Output: src/blocks/rich-text.ts with richTextToMd() and a comprehensive test suite.
</objective>

<execution_context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
</execution_context>

<context>
@.planning/phases/01-foundation-auth/01-01-SUMMARY.md
@.planning/research/PITFALLS.md

<interfaces>
<!-- Notion SDK rich text types — what richTextToMd() will receive -->
From @notionhq/client (imported as types):
```typescript
// Rich text item union — each segment in a rich_text array is one of these
type RichTextItemResponse =
  | {
      type: "text";
      text: { content: string; link: { url: string } | null };
      annotations: Annotations;
      plain_text: string;
      href: string | null;
    }
  | {
      type: "mention";
      mention: MentionRichTextItemResponse["mention"]; // user, page, database, date, etc.
      annotations: Annotations;
      plain_text: string;
      href: string | null;
    }
  | {
      type: "equation";
      equation: { expression: string };
      annotations: Annotations;
      plain_text: string;
      href: string | null;
    };

interface Annotations {
  bold: boolean;
  italic: boolean;
  strikethrough: boolean;
  underline: boolean;
  code: boolean;
  color: string; // "default", "red", "blue", etc.
}
```

From src/output/color.ts (already built):
```typescript
// Only use these for stderr — stdout must be plain text for agent compatibility
export function error(msg: string): string
export function dim(msg: string): string
```
</interfaces>
</context>

<feature>
  <name>Rich text segment array to markdown string converter</name>
  <files>src/blocks/rich-text.ts, tests/blocks/rich-text.test.ts</files>
  <behavior>
Export a single function:
```typescript
export function richTextToMd(richText: RichTextItemResponse[]): string
```

**RED phase test cases — write ALL failing tests first:**

```typescript
// Empty
richTextToMd([]) === ''

// Plain text (no annotations)
richTextToMd([{type:'text', plain_text:'hello', text:{content:'hello',link:null}, annotations:{bold:false,italic:false,strikethrough:false,underline:false,code:false,color:'default'}, href:null}])
=== 'hello'

// Bold
// annotations.bold = true → **hello**
=== '**hello**'

// Italic
// annotations.italic = true → _hello_
=== '_hello_'

// Bold + italic
// both true → **_hello_**
=== '**_hello_**'

// Inline code
// annotations.code = true → `hello`
=== '`hello`'

// Strikethrough
// annotations.strikethrough = true → ~~hello~~
=== '~~hello~~'

// Underline
// annotations.underline = true → plain text (no markdown equivalent, keep as-is)
=== 'hello'

// Color (non-default)
// annotations.color = 'red' → plain text (markdown has no color, keep as-is)
=== 'hello'

// Link (type='text', text.link.url = 'https://example.com')
// → [hello](https://example.com)
=== '[hello](https://example.com)'

// Link + bold (text.link exists AND bold=true)
// → [**hello**](https://example.com)
=== '[**hello**](https://example.com)'

// Multiple segments concatenated
// ['hello', ' ', 'world'] → 'hello world'
// [{plain_text:'hello',bold:true}, {plain_text:' world',bold:false}] → '**hello** world'
=== '**hello** world'

// Mention (type='mention', mention.type='user') → @display_name
// use plain_text field as the mention display

// Equation (type='equation', equation.expression='e=mc^2') → $e=mc^2$
=== '$e=mc^2$'

// href field (external link on a non-text segment)
// When href is not null (e.g. on a mention with a link), wrap as [plain_text](href)
```

**GREEN phase implementation notes:**
- Import `RichTextItemResponse` from `@notionhq/client/build/src/api-endpoints.js`
- For `type='text'`: wrap content with annotation markers (inner to outer: code → strikethrough → italic → bold), then wrap in link if `text.link` is non-null
- For `type='mention'`: use `plain_text` field, wrap in link if `href` is non-null
- For `type='equation'`: wrap expression in `$...$`
- Annotation application order (inner wraps first): code `` `x` `` → strikethrough `~~x~~` → italic `_x_` → bold `**x**`
- Underline: no markdown equivalent — output plain text (do NOT use HTML `<u>` tags — agents need clean markdown)
- Color: no markdown equivalent — output plain text
- Concatenate all segment results with no separator

**REFACTOR phase:** Extract annotation wrapping helper if it simplifies the code. No behavior changes.
  </behavior>
  <implementation>
Create `src/blocks/rich-text.ts` with:
1. Import `RichTextItemResponse` from SDK types
2. Inner helper `applyAnnotations(text: string, ann: Annotations): string` — applies annotations inner-to-outer
3. Export `richTextToMd(richText: RichTextItemResponse[]): string` — maps each segment to string and joins

Keep the file small (< 50 lines). No external dependencies beyond the SDK type.
  </implementation>
</feature>

<verification>
- `npx vitest run tests/blocks/rich-text.test.ts` passes with 0 failures
- `npx tsc --noEmit` passes with no type errors in src/blocks/rich-text.ts
- Test file covers: empty, plain, bold, italic, bold+italic, code, strikethrough, underline (passthrough), link, link+bold, multi-segment, mention, equation
</verification>

<success_criteria>
- All test cases pass (RED → GREEN achieved)
- richTextToMd([]) returns ''
- Bold, italic, code, strikethrough annotations produce correct markdown wrapping
- Links produce [text](url) with annotations applied inside the link text
- Equations produce $expression$
- Underline and color produce plain text (no HTML)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-page-reading/03-01-SUMMARY.md`
</output>
