---
phase: 03-page-reading
plan: "04"
type: execute
wave: 3
depends_on:
  - "03-02"
  - "03-03"
files_modified:
  - src/blocks/render.ts
  - src/commands/read.ts
  - src/cli.ts
autonomous: false
requirements:
  - PAGE-01
  - PAGE-02
  - PAGE-03
  - PAGE-04

must_haves:
  truths:
    - "User can run `notion read <page-id>` and receive full page content as markdown"
    - "Page properties appear as a YAML frontmatter block before page content"
    - "Block tree renders depth-first, children indented under parents"
    - "Numbered list items auto-number sequentially (1, 2, 3) within each list group"
    - "notion read --json outputs raw page JSON (page object + raw block tree)"
    - "notion read with a Notion URL (not just ID) works correctly"
    - "Unsupported block types render as HTML comments, not errors"
  artifacts:
    - path: "src/blocks/render.ts"
      provides: "Page markdown assembler: walks BlockNode tree + properties header"
      exports: ["renderPageMarkdown"]
    - path: "src/commands/read.ts"
      provides: "notion read <id/url> command implementation"
      exports: ["readCommand"]
    - path: "src/cli.ts"
      provides: "read command registered in CLI program"
      contains: "readCommand"
  key_links:
    - from: "src/commands/read.ts"
      to: "src/services/page.service.ts"
      via: "import { fetchPageWithBlocks } from '../services/page.service.js'"
      pattern: "fetchPageWithBlocks"
    - from: "src/commands/read.ts"
      to: "src/blocks/render.ts"
      via: "import { renderPageMarkdown } from '../blocks/render.js'"
      pattern: "renderPageMarkdown"
    - from: "src/commands/read.ts"
      to: "src/notion/url-parser.ts"
      via: "import { parseNotionId } from '../notion/url-parser.js'"
      pattern: "parseNotionId"
    - from: "src/cli.ts"
      to: "src/commands/read.ts"
      via: "import { readCommand } from './commands/read.js'"
      pattern: "readCommand"
---

<objective>
Assemble the `notion read` command by wiring the block tree walker, block converters, and properties formatter into a complete page reading pipeline.

Purpose: This is the integration plan — all the converters and services built in prior plans come together here. The `renderPageMarkdown()` function handles depth-first tree walking with list context, and the `notion read` command exposes it via the CLI.
Output: src/blocks/render.ts (page assembler), src/commands/read.ts (CLI command), updated src/cli.ts
</objective>

<execution_context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
</execution_context>

<context>
@.planning/phases/03-page-reading/03-02-SUMMARY.md
@.planning/phases/03-page-reading/03-03-SUMMARY.md
@.planning/phases/01-foundation-auth/01-04-SUMMARY.md

<interfaces>
<!-- From Plan 03-01 (Wave 1) -->
From src/blocks/rich-text.ts:
```typescript
export function richTextToMd(richText: RichTextItemResponse[]): string
```

<!-- From Plan 03-02 (Wave 1) -->
From src/services/page.service.ts:
```typescript
export interface BlockNode {
  block: BlockObjectResponse;
  children: BlockNode[];
}

export interface PageWithBlocks {
  page: PageObjectResponse;
  blocks: BlockNode[];
}

export async function fetchPageWithBlocks(
  client: Client,
  pageId: string,
): Promise<PageWithBlocks>
```

From src/blocks/properties.ts:
```typescript
export function formatPropertyValue(
  name: string,
  prop: PageObjectResponse['properties'][string],
): string

export function extractPageTitle(page: PageObjectResponse): string
```

<!-- From Plan 03-03 (Wave 2) -->
From src/blocks/converters.ts:
```typescript
export interface BlockConverterContext {
  listNumber?: number;
  childrenMd?: string;
}

export function blockToMd(
  block: BlockObjectResponse,
  ctx?: BlockConverterContext,
): string
```

<!-- From Phase 1 infrastructure -->
From src/notion/url-parser.ts:
```typescript
export function parseNotionId(input: string): string // throws CliError on invalid input
```

From src/notion/client.ts:
```typescript
export function createNotionClient(token: string): Client
```

From src/errors/error-handler.ts:
```typescript
export function withErrorHandling<T extends unknown[]>(
  fn: (...args: T) => Promise<void>,
): (...args: T) => Promise<void>
```

From src/config/token.ts (or similar from Phase 1):
```typescript
export async function resolveToken(): Promise<TokenResult>
```

From src/output/format.ts (Phase 2 — will exist when Phase 3 executes):
```typescript
export type OutputMode = 'auto' | 'json' | 'md';
export function setOutputMode(mode: OutputMode): void
export function formatJSON(data: unknown): string
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Page markdown assembler (render.ts)</name>
  <files>src/blocks/render.ts</files>
  <action>
Create `src/blocks/render.ts` that assembles the complete page markdown from a PageWithBlocks structure.

**Export one function:**
```typescript
export function renderPageMarkdown(pageWithBlocks: PageWithBlocks): string
```

**Implementation:**

**Step 1: Build properties frontmatter header**

```typescript
function buildPropertiesHeader(page: PageObjectResponse): string {
  const lines: string[] = ['---'];
  for (const [name, prop] of Object.entries(page.properties)) {
    const value = formatPropertyValue(name, prop);
    if (value) {
      lines.push(`${name}: ${value}`);
    }
  }
  lines.push('---', '');
  return lines.join('\n');
}
```

Only include properties that have non-empty values. The `---` fences make it YAML frontmatter.

**Step 2: Walk block tree depth-first with list context**

```typescript
function renderBlockTree(blocks: BlockNode[]): string {
  const parts: string[] = [];
  let listCounter = 0;  // tracks consecutive numbered_list_item

  for (const node of blocks) {
    // Track numbered list position
    if (node.block.type === 'numbered_list_item') {
      listCounter++;
    } else {
      listCounter = 0;  // reset on any non-numbered block
    }

    // Recursively render children first
    const childrenMd = node.children.length > 0
      ? renderBlockTree(node.children)
      : '';

    const md = blockToMd(node.block, {
      listNumber: node.block.type === 'numbered_list_item' ? listCounter : undefined,
      childrenMd: childrenMd || undefined,
    });

    parts.push(md);
  }

  return parts.join('');
}
```

**Step 3: renderPageMarkdown assembles the pieces**

```typescript
export function renderPageMarkdown({ page, blocks }: PageWithBlocks): string {
  const header = buildPropertiesHeader(page);
  const content = renderBlockTree(blocks);
  return header + content;
}
```

The function returns a single string with:
1. YAML frontmatter header (properties)
2. Page content (block tree as markdown)

No stdout writes here — the command handles output.
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep "render.ts" || echo "no errors"</verify>
  <done>src/blocks/render.ts exists, exports renderPageMarkdown. Numbered list counter resets correctly. Children rendered recursively. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: notion read command + CLI wiring</name>
  <files>src/commands/read.ts, src/cli.ts</files>
  <action>
Create `src/commands/read.ts` implementing `notion read <id/url>` and register it in `src/cli.ts`.

**src/commands/read.ts:**

```typescript
import { Command } from 'commander';
import { withErrorHandling } from '../errors/error-handler.js';
import { resolveToken } from '../config/token.js';
import { createNotionClient } from '../notion/client.js';
import { parseNotionId } from '../notion/url-parser.js';
import { fetchPageWithBlocks } from '../services/page.service.js';
import { renderPageMarkdown } from '../blocks/render.js';

export function readCommand(): Command {
  return new Command('read')
    .description('Read a Notion page as markdown')
    .argument('<id>', 'Notion page ID or URL')
    .option('--json', 'Output raw JSON instead of markdown')
    .action(
      withErrorHandling(async (id: string, options: { json?: boolean }) => {
        const { token } = await resolveToken();
        const client = createNotionClient(token);
        const pageId = parseNotionId(id);
        const pageWithBlocks = await fetchPageWithBlocks(client, pageId);

        if (options.json) {
          process.stdout.write(JSON.stringify(pageWithBlocks, null, 2) + '\n');
        } else {
          const markdown = renderPageMarkdown(pageWithBlocks);
          process.stdout.write(markdown);
        }
      }),
    );
}
```

**Important:** `resolveToken()` is the standard auth pattern from Phase 1. Check the actual import path — it may be `../config/token.js` (if `resolveToken` is exported from `src/config/token.ts`) or `../config/config.js` depending on how Phase 1 exported it. Look at how Phase 1 commands (e.g., `src/commands/init.ts`) import `resolveToken` and use the same path.

**src/cli.ts changes:**

Add to the existing `src/cli.ts` (which already registers init, profile, completion):

```typescript
// Import at top (with other command imports):
import { readCommand } from './commands/read.js';

// Add to program (in the "--- Content ---" section, after auth commands):
// --- Content ---
program.addCommand(readCommand());
```

Register the command after the profile commands, before completionCommand.
  </action>
  <verify>npm run build 2>&1 | tail -5 && notion read --help 2>&1</verify>
  <done>npm run build succeeds. `notion read --help` shows "Read a Notion page as markdown" with `<id>` argument and `--json` option. src/cli.ts imports and registers readCommand.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify notion read end-to-end with a real Notion page</name>
  <files>— (no files modified; human verification only)</files>
  <action>Human verification of the complete notion read pipeline. Follow how-to-verify steps below.</action>
  <verify>User approves the checkpoint via resume-signal</verify>
  <done>User types "approved" confirming notion read outputs correct markdown for a real Notion page</done>
  <what-built>
    Complete `notion read` pipeline:
    - src/blocks/render.ts — page markdown assembler with properties frontmatter + block tree walker
    - src/commands/read.ts — notion read &lt;id/url&gt; command (markdown output default, --json override)
    - src/cli.ts — read command registered
    
    All Phase 3 plans wired together:
    - Rich text annotations → markdown (03-01)
    - Page service + properties formatter (03-02)
    - Block type converters (03-03)
    - Render + command (this plan)
  </what-built>
  <how-to-verify>
    1. Build the project: `npm run build`
    2. Run `notion --help` — verify "read" appears in command list
    3. Run `notion read --help` — verify description, &lt;id&gt; argument, --json flag
    4. Run `notion read &lt;a-real-page-id-or-url&gt;` — verify:
       - Output starts with `---` frontmatter header
       - Properties like Title, Status, dates appear in the header
       - Page content appears after the closing `---`
       - Headings render as #/##/###
       - Bold/italic text renders with ** and _
       - Code blocks have ``` fences
    5. Run `notion read --json &lt;page-id&gt;` — verify JSON output with page + blocks structure
    6. Run `notion read &lt;full-notion-url&gt;` — verify URL parsing works
    7. Run `notion read invalid-id-12345` — verify helpful error message to stderr, exit code 1
  </how-to-verify>
  <resume-signal>Type "approved" if the read command works. Describe any issues if not.</resume-signal>
</task>

</tasks>

<verification>
- `npm run build` succeeds (no TypeScript errors)
- `notion read --help` shows correct usage
- `notion read <real-page-id>` outputs valid markdown with properties frontmatter
- `notion read --json <page-id>` outputs JSON
- `notion read <notion-url>` works (URL → ID parsing)
- `notion read bad-id` shows helpful error via stderr
- `npx vitest run` passes (all prior TDD tests still passing)
</verification>

<success_criteria>
- All 4 Phase 3 requirements addressed: PAGE-01, PAGE-02, PAGE-03, PAGE-04
- notion read outputs markdown with properties header and all block types converted
- Rich text annotations (bold, italic, code, links) render correctly in output
- Command registered in CLI, build succeeds
- User approves the checkpoint verification
</success_criteria>

<output>
After completion, create `.planning/phases/03-page-reading/03-04-SUMMARY.md`
</output>
